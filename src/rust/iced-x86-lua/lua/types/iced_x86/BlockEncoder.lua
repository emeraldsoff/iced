-- SPDX-License-Identifier: MIT
-- Copyright (C) 2018-present iced project and contributors

-- ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

---@meta
---@diagnostic disable unused-local

---Encodes instructions
---
---`Encoder` can only encode one instruction at a time. This class can encode any number of
---instructions and can also fix short branches if the target is too far away.
---
---It will fail if there's an instruction with an RIP-relative operand (`[rip+123h]`) and the target is too far away.
---A workaround is to use a new base RIP of the encoded instructions that is close (+/-2GB) to the original location.
---
---# Examples
---
---```lua
---local BlockEncoder = require("iced_x86.BlockEncoder")
---local Decoder = require("iced_x86.Decoder")
---
---local data = "\134\100\050\022\240\242\131\000\090\098\193\254\203\111\211"
---local decoder = Decoder.new(64, data, nil, 0x12345678)
---
---local instrs = {}
---for instr in decoder:iter_out() do
---    instrs[#instrs + 1] = instr:copy()
---end
---
----- Encode all added instructions and get the raw bytes
---local result = BlockEncoder.encode(64, instrs, 0x3456789A)
---local raw_data = result.code_buffer
---
----- It has no IP-relative instructions (eg. branches or [rip+xxx] ops)
----- so the result should be identical to the original code.
---assert(#data, #raw_data)
---for i = 1, #data do
---    assert(data[i] == raw_data[i])
---end
---```
---
---@class BlockEncoder
local BlockEncoder = {}

---Encodes all instructions and returns the raw bytes
---
---Error if one or more instructions couldn't be encoded.
---
---@param bitness integer #16, 32 or 64
---@param instructions Instruction[] #Instructions to encode
---@param rip integer #Base IP of all encoded instructions
---@param options? integer #(optional, default = `BlockEncoderOptions.None`) Options
---@return table
function BlockEncoder.encode(bitness, instructions, rip, options) end

return BlockEncoder
