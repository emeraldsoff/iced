-- SPDX-License-Identifier: MIT
-- Copyright (C) 2018-present iced project and contributors

-- ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

---@meta
---@diagnostic disable unused-local

---Encodes instructions decoded by the decoder or instructions created by other code.
---See also `BlockEncoder` which can encode any number of instructions.
---
---@class Encoder
local Encoder = {}

---Encodes instructions decoded by the decoder or instructions created by other code.
---
---See also `BlockEncoder` which can encode any number of instructions.
---
---@param bitness integer #16, 32 or 64
---@param capacity? integer #(default = 0) Initial capacity of the byte buffer
---@return Encoder
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local Encoder = require("iced_x86.Encoder")
---
----- xchg ah,[rdx+rsi+16h]
---local data = "\134\100\050\022"
---local decoder = Decoder.new(64, data, nil, 0x12345678)
---local instr = decoder:decode()
---
---local encoder = Encoder.new(64)
---local instr_len = encoder:encode(instr, 0x55555555)
---assert(instr_len == 4)
---
----- We're done, take ownership of the buffer
---local buffer = encoder:take_buffer()
---assert(buffer == "\134\100\050\022")
---```
function Encoder.new(bitness, capacity) end

---Encodes an instruction and returns the size of the encoded instruction
---
---Error if it failed to encode the instruction (eg. a target branch / RIP-rel operand is too far away)
---
---@param instruction Instruction #Instruction to encode
---@param rip integer #(`u64`) `RIP` of the encoded instruction
---@return integer #Size of the encoded instruction
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local Encoder = require("iced_x86.Encoder")
---
----- je short $+4
---local data = "\117\002"
---local decoder = Decoder.new(64, data, nil, 0x12345678)
---local instr = decoder:decode()
---
---local encoder = Encoder.new(64)
----- Use a different IP (orig rip + 0x10)
---local instr_len = encoder:encode(instr, 0x12345688)
---assert(instr_len == 2)
---
----- We're done, take ownership of the buffer
---local buffer = encoder:take_buffer()
---assert(buffer == "\117\242")
---```
function Encoder:encode(instruction, rip) end

---Writes a byte to the output buffer
---
---@param value integer #(`u8`) Value to write
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local Encoder = require("iced_x86.Encoder")
---
----- je short $+4
---local data = "\117\002"
---local decoder = Decoder.new(64, data, nil, 0x12345678)
---local instr = decoder:decode()
---
---local encoder = Encoder.new(64)
----- Add a random byte
---encoder:write_u8(0x90)
---
----- Use a different IP (orig rip + 0x10)
---local instr_len = encoder:encode(instr, 0x12345688)
---assert(instr_len == 2)
---
----- Add a random byte
---encoder:write_u8(0x90)
---
----- We're done, take ownership of the buffer
---local buffer = encoder:take_buffer()
---assert(buffer == "\144\117\242\144")
---```
function Encoder:write_u8(value) end

---Returns the buffer and initializes the internal buffer to an empty array.
---
---Should be called when you've encoded all instructions and need the raw instruction bytes.
---
---@return string #The encoded instructions
function Encoder:take_buffer() end

---Gets the offsets of the constants (memory displacement and immediate) in the encoded instruction.
---
---The caller can use this information to add relocations if needed.
---
---@return ConstantOffsets #Offsets and sizes of immediates
function Encoder:get_constant_offsets() end

---Disables 2-byte VEX encoding and encodes all VEX instructions with the 3-byte VEX encoding
---
---@return boolean
function Encoder:prevent_vex2() end

---Disables 2-byte VEX encoding and encodes all VEX instructions with the 3-byte VEX encoding
---
---@param new_value boolean #New value
function Encoder:set_prevent_vex2(new_value) end

---Value of the `VEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@return integer
function Encoder:vex_wig() end

---Value of the `VEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@param new_value integer #New value
function Encoder:set_vex_wig(new_value) end

---Value of the `VEX.L` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@return integer
function Encoder:vex_lig() end

---Value of the `VEX.L` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@param new_value integer #New value
function Encoder:set_vex_lig(new_value) end

---Value of the `EVEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@return integer
function Encoder:evex_wig() end

---Value of the `EVEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@param new_value integer #New value
function Encoder:set_evex_wig(new_value) end

---Value of the `EVEX.L'L` bits to use if it's an instruction that ignores the bits. Default is 0.
---
---@return integer
function Encoder:evex_lig() end

---Value of the `EVEX.L'L` bits to use if it's an instruction that ignores the bits. Default is 0.
---
---@param new_value integer #New value
function Encoder:set_evex_lig(new_value) end

---Value of the `MVEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@return integer
function Encoder:mvex_wig() end

---Value of the `MVEX.W` bit to use if it's an instruction that ignores the bit. Default is 0.
---
---@param new_value integer #New value
function Encoder:set_mvex_wig(new_value) end

---Gets the bitness (16, 32 or 64)
---
---@return integer
function Encoder:bitness() end

return Encoder
