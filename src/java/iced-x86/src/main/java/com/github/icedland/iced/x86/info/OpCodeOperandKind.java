// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

package com.github.icedland.iced.x86.info;

/**
 * Operand kind
 */
public final class OpCodeOperandKind {
	private OpCodeOperandKind() {
	}

	/**
	 * No operand
	 */
	public static final int NONE = 0;
	/**
	 * Far branch 16-bit offset, 16-bit segment/selector
	 */
	public static final int FARBR2_2 = 1;
	/**
	 * Far branch 32-bit offset, 16-bit segment/selector
	 */
	public static final int FARBR4_2 = 2;
	/**
	 * Memory offset without a modrm byte (eg.<!-- --> {@code MOV AL,[offset]})
	 */
	public static final int MEM_OFFS = 3;
	/**
	 * Memory (modrm)
	 */
	public static final int MEM = 4;
	/**
	 * Memory (modrm), MPX:<p>
	 * 16/32-bit mode: must be 32-bit addressing<p>
	 * 64-bit mode: 64-bit addressing is forced and must not be RIP relative
	 */
	public static final int MEM_MPX = 5;
	/**
	 * Memory (modrm), MPX:<p>
	 * 16/32-bit mode: must be 32-bit addressing<p>
	 * 64-bit mode: 64-bit addressing is forced and must not be RIP relative
	 */
	public static final int MEM_MIB = 6;
	/**
	 * Memory (modrm), vsib32, {@code XMM} registers
	 */
	public static final int MEM_VSIB32X = 7;
	/**
	 * Memory (modrm), vsib64, {@code XMM} registers
	 */
	public static final int MEM_VSIB64X = 8;
	/**
	 * Memory (modrm), vsib32, {@code YMM} registers
	 */
	public static final int MEM_VSIB32Y = 9;
	/**
	 * Memory (modrm), vsib64, {@code YMM} registers
	 */
	public static final int MEM_VSIB64Y = 10;
	/**
	 * Memory (modrm), vsib32, {@code ZMM} registers
	 */
	public static final int MEM_VSIB32Z = 11;
	/**
	 * Memory (modrm), vsib64, {@code ZMM} registers
	 */
	public static final int MEM_VSIB64Z = 12;
	/**
	 * 8-bit GPR or memory
	 */
	public static final int R8_OR_MEM = 13;
	/**
	 * 16-bit GPR or memory
	 */
	public static final int R16_OR_MEM = 14;
	/**
	 * 32-bit GPR or memory
	 */
	public static final int R32_OR_MEM = 15;
	/**
	 * 32-bit GPR or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
	 */
	public static final int R32_OR_MEM_MPX = 16;
	/**
	 * 64-bit GPR or memory
	 */
	public static final int R64_OR_MEM = 17;
	/**
	 * 64-bit GPR or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
	 */
	public static final int R64_OR_MEM_MPX = 18;
	/**
	 * {@code MM} register or memory
	 */
	public static final int MM_OR_MEM = 19;
	/**
	 * {@code XMM} register or memory
	 */
	public static final int XMM_OR_MEM = 20;
	/**
	 * {@code YMM} register or memory
	 */
	public static final int YMM_OR_MEM = 21;
	/**
	 * {@code ZMM} register or memory
	 */
	public static final int ZMM_OR_MEM = 22;
	/**
	 * {@code BND} register or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
	 */
	public static final int BND_OR_MEM_MPX = 23;
	/**
	 * {@code K} register or memory
	 */
	public static final int K_OR_MEM = 24;
	/**
	 * 8-bit GPR encoded in the {@code reg} field of the modrm byte
	 */
	public static final int R8_REG = 25;
	/**
	 * 8-bit GPR encoded in the low 3 bits of the opcode
	 */
	public static final int R8_OPCODE = 26;
	/**
	 * 16-bit GPR encoded in the {@code reg} field of the modrm byte
	 */
	public static final int R16_REG = 27;
	/**
	 * 16-bit GPR encoded in the {@code reg} field of the modrm byte.<!-- --> This is a memory operand and it uses the address size prefix ({@code 67h}) not the operand size prefix ({@code 66h}).<!-- -->
	 */
	public static final int R16_REG_MEM = 28;
	/**
	 * 16-bit GPR encoded in the {@code mod + r/m} fields of the modrm byte
	 */
	public static final int R16_RM = 29;
	/**
	 * 16-bit GPR encoded in the low 3 bits of the opcode
	 */
	public static final int R16_OPCODE = 30;
	/**
	 * 32-bit GPR encoded in the {@code reg} field of the modrm byte
	 */
	public static final int R32_REG = 31;
	/**
	 * 32-bit GPR encoded in the {@code reg} field of the modrm byte.<!-- --> This is a memory operand and it uses the address size prefix ({@code 67h}) not the operand size prefix ({@code 66h}).<!-- -->
	 */
	public static final int R32_REG_MEM = 32;
	/**
	 * 32-bit GPR encoded in the {@code mod + r/m} fields of the modrm byte
	 */
	public static final int R32_RM = 33;
	/**
	 * 32-bit GPR encoded in the low 3 bits of the opcode
	 */
	public static final int R32_OPCODE = 34;
	/**
	 * 32-bit GPR encoded in the the {@code V'vvvv} field (VEX/EVEX/XOP)
	 */
	public static final int R32_VVVV = 35;
	/**
	 * 64-bit GPR encoded in the {@code reg} field of the modrm byte
	 */
	public static final int R64_REG = 36;
	/**
	 * 64-bit GPR encoded in the {@code reg} field of the modrm byte.<!-- --> This is a memory operand and it uses the address size prefix ({@code 67h}) not the operand size prefix ({@code 66h}).<!-- -->
	 */
	public static final int R64_REG_MEM = 37;
	/**
	 * 64-bit GPR encoded in the {@code mod + r/m} fields of the modrm byte
	 */
	public static final int R64_RM = 38;
	/**
	 * 64-bit GPR encoded in the low 3 bits of the opcode
	 */
	public static final int R64_OPCODE = 39;
	/**
	 * 64-bit GPR encoded in the the {@code V'vvvv} field (VEX/EVEX/XOP)
	 */
	public static final int R64_VVVV = 40;
	/**
	 * Segment register encoded in the {@code reg} field of the modrm byte
	 */
	public static final int SEG_REG = 41;
	/**
	 * {@code K} register encoded in the {@code reg} field of the modrm byte
	 */
	public static final int K_REG = 42;
	/**
	 * {@code K} register (+1) encoded in the {@code reg} field of the modrm byte
	 */
	public static final int KP1_REG = 43;
	/**
	 * {@code K} register encoded in the {@code mod + r/m} fields of the modrm byte
	 */
	public static final int K_RM = 44;
	/**
	 * {@code K} register encoded in the the {@code V'vvvv} field (VEX/EVEX/MVEX/XOP)
	 */
	public static final int K_VVVV = 45;
	/**
	 * {@code MM} register encoded in the {@code reg} field of the modrm byte
	 */
	public static final int MM_REG = 46;
	/**
	 * {@code MM} register encoded in the {@code mod + r/m} fields of the modrm byte
	 */
	public static final int MM_RM = 47;
	/**
	 * {@code XMM} register encoded in the {@code reg} field of the modrm byte
	 */
	public static final int XMM_REG = 48;
	/**
	 * {@code XMM} register encoded in the {@code mod + r/m} fields of the modrm byte
	 */
	public static final int XMM_RM = 49;
	/**
	 * {@code XMM} register encoded in the the {@code V'vvvv} field (VEX/EVEX/XOP)
	 */
	public static final int XMM_VVVV = 50;
	/**
	 * {@code XMM} register (+3) encoded in the the {@code V'vvvv} field (VEX/EVEX/XOP)
	 */
	public static final int XMMP3_VVVV = 51;
	/**
	 * {@code XMM} register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only {@code XMM0}-{@code XMM15})
	 */
	public static final int XMM_IS4 = 52;
	/**
	 * {@code XMM} register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only {@code XMM0}-{@code XMM15})
	 */
	public static final int XMM_IS5 = 53;
	/**
	 * {@code YMM} register encoded in the {@code reg} field of the modrm byte
	 */
	public static final int YMM_REG = 54;
	/**
	 * {@code YMM} register encoded in the {@code mod + r/m} fields of the modrm byte
	 */
	public static final int YMM_RM = 55;
	/**
	 * {@code YMM} register encoded in the the {@code V'vvvv} field (VEX/EVEX/XOP)
	 */
	public static final int YMM_VVVV = 56;
	/**
	 * {@code YMM} register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only {@code YMM0}-{@code YMM15})
	 */
	public static final int YMM_IS4 = 57;
	/**
	 * {@code YMM} register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only {@code YMM0}-{@code YMM15})
	 */
	public static final int YMM_IS5 = 58;
	/**
	 * {@code ZMM} register encoded in the {@code reg} field of the modrm byte
	 */
	public static final int ZMM_REG = 59;
	/**
	 * {@code ZMM} register encoded in the {@code mod + r/m} fields of the modrm byte
	 */
	public static final int ZMM_RM = 60;
	/**
	 * {@code ZMM} register encoded in the the {@code V'vvvv} field (VEX/EVEX/MVEX/XOP)
	 */
	public static final int ZMM_VVVV = 61;
	/**
	 * {@code ZMM} register (+3) encoded in the the {@code V'vvvv} field (VEX/EVEX/XOP)
	 */
	public static final int ZMMP3_VVVV = 62;
	/**
	 * {@code CR} register encoded in the {@code reg} field of the modrm byte
	 */
	public static final int CR_REG = 63;
	/**
	 * {@code DR} register encoded in the {@code reg} field of the modrm byte
	 */
	public static final int DR_REG = 64;
	/**
	 * {@code TR} register encoded in the {@code reg} field of the modrm byte
	 */
	public static final int TR_REG = 65;
	/**
	 * {@code BND} register encoded in the {@code reg} field of the modrm byte
	 */
	public static final int BND_REG = 66;
	/**
	 * {@code ES} register
	 */
	public static final int ES = 67;
	/**
	 * {@code CS} register
	 */
	public static final int CS = 68;
	/**
	 * {@code SS} register
	 */
	public static final int SS = 69;
	/**
	 * {@code DS} register
	 */
	public static final int DS = 70;
	/**
	 * {@code FS} register
	 */
	public static final int FS = 71;
	/**
	 * {@code GS} register
	 */
	public static final int GS = 72;
	/**
	 * {@code AL} register
	 */
	public static final int AL = 73;
	/**
	 * {@code CL} register
	 */
	public static final int CL = 74;
	/**
	 * {@code AX} register
	 */
	public static final int AX = 75;
	/**
	 * {@code DX} register
	 */
	public static final int DX = 76;
	/**
	 * {@code EAX} register
	 */
	public static final int EAX = 77;
	/**
	 * {@code RAX} register
	 */
	public static final int RAX = 78;
	/**
	 * {@code ST(0)} register
	 */
	public static final int ST0 = 79;
	/**
	 * {@code ST(i)} register encoded in the low 3 bits of the opcode
	 */
	public static final int STI_OPCODE = 80;
	/**
	 * 4-bit immediate (m2z field, low 4 bits of the /is5 immediate, eg.<!-- --> {@code VPERMIL2PS})
	 */
	public static final int IMM4_M2Z = 81;
	/**
	 * 8-bit immediate
	 */
	public static final int IMM8 = 82;
	/**
	 * Constant 1 (8-bit immediate)
	 */
	public static final int IMM8_CONST_1 = 83;
	/**
	 * 8-bit immediate sign extended to 16 bits
	 */
	public static final int IMM8SEX16 = 84;
	/**
	 * 8-bit immediate sign extended to 32 bits
	 */
	public static final int IMM8SEX32 = 85;
	/**
	 * 8-bit immediate sign extended to 64 bits
	 */
	public static final int IMM8SEX64 = 86;
	/**
	 * 16-bit immediate
	 */
	public static final int IMM16 = 87;
	/**
	 * 32-bit immediate
	 */
	public static final int IMM32 = 88;
	/**
	 * 32-bit immediate sign extended to 64 bits
	 */
	public static final int IMM32SEX64 = 89;
	/**
	 * 64-bit immediate
	 */
	public static final int IMM64 = 90;
	/**
	 * {@code seg:[rSI]} memory operand (string instructions)
	 */
	public static final int SEG_RSI = 91;
	/**
	 * {@code es:[rDI]} memory operand (string instructions)
	 */
	public static final int ES_RDI = 92;
	/**
	 * {@code seg:[rDI]} memory operand ({@code (V)MASKMOVQ} instructions)
	 */
	public static final int SEG_RDI = 93;
	/**
	 * {@code seg:[rBX+al]} memory operand ({@code XLATB} instruction)
	 */
	public static final int SEG_RBX_AL = 94;
	/**
	 * 16-bit branch, 1-byte signed relative offset
	 */
	public static final int BR16_1 = 95;
	/**
	 * 32-bit branch, 1-byte signed relative offset
	 */
	public static final int BR32_1 = 96;
	/**
	 * 64-bit branch, 1-byte signed relative offset
	 */
	public static final int BR64_1 = 97;
	/**
	 * 16-bit branch, 2-byte signed relative offset
	 */
	public static final int BR16_2 = 98;
	/**
	 * 32-bit branch, 4-byte signed relative offset
	 */
	public static final int BR32_4 = 99;
	/**
	 * 64-bit branch, 4-byte signed relative offset
	 */
	public static final int BR64_4 = 100;
	/**
	 * {@code XBEGIN}, 2-byte signed relative offset
	 */
	public static final int XBEGIN_2 = 101;
	/**
	 * {@code XBEGIN}, 4-byte signed relative offset
	 */
	public static final int XBEGIN_4 = 102;
	/**
	 * 2-byte branch offset ({@code JMPE} instruction)
	 */
	public static final int BRDISP_2 = 103;
	/**
	 * 4-byte branch offset ({@code JMPE} instruction)
	 */
	public static final int BRDISP_4 = 104;
	/**
	 * Memory (modrm) and the sib byte must be present
	 */
	public static final int SIBMEM = 105;
	/**
	 * {@code TMM} register encoded in the {@code reg} field of the modrm byte
	 */
	public static final int TMM_REG = 106;
	/**
	 * {@code TMM} register encoded in the {@code mod + r/m} fields of the modrm byte
	 */
	public static final int TMM_RM = 107;
	/**
	 * {@code TMM} register encoded in the the {@code V'vvvv} field (VEX/EVEX/XOP)
	 */
	public static final int TMM_VVVV = 108;
}
